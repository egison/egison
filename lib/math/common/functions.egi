--
-- Mathematical Functions
--

def abs (x: MathExpr) : MathExpr := if isRational x then i.abs x else 'abs x

def exp (x: MathExpr) : MathExpr :=
  if isTerm x
    then match x as termExpr with
      | #0 -> 1
      | #1 -> e
      | mult $a #(i * π) -> (-1) ^ a
      | _ -> 'exp x
    else 'exp x

def log (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #1 -> 0
    | #e -> 1
    | _ -> 'log x

def cos (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 1
    | mult $n #π -> (-1) ^ abs n
    | (mult _ #π) / #2 -> 0
    | _ -> 'cos x

def sin (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 0
    | mult _ #π -> 0
    | (mult $n #π) / #2 -> (-1) ^ ((abs n - 1) / 2)
    | _ -> 'sin x

def tan (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 0
    | _ -> 'tan x

--def acos : MathExpr -> MathExpr := f.acos
--def asin : MathExpr -> MathExpr := f.asin
--def atan : MathExpr -> MathExpr := f.atan

def cosh (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 1
    | _ -> 'cosh x

def sinh (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 0
    | _ -> 'sinh x

def tanh (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 0
    | _ -> 'tanh x

--def acosh : MathExpr -> MathExpr := f.acosh
--def asinh : MathExpr -> MathExpr := f.asinh
--def atanh : MathExpr -> MathExpr := f.atanh

def sinc (x: MathExpr) : MathExpr :=
  match x as mathExpr with
    | #0 -> 1
    | _ -> sin x / x

def sigmoid (z: MathExpr) : MathExpr := 1 / (1 + exp (- z))

def kroneckerDelta (js: [Integer]) : Integer := 
  if all (= head js) (tail js) then 1 else 0

def eulerTotientFunction (n: Integer) : MathExpr := 
  n * product (map (\p -> 1 - 1 / p) (unique (pF n)))

def ε : Integer -> Tensor Integer :=
  memoizedLambda n ->
    let (es, os) := evenAndOddPermutations' n
     in generateTensor
          (\is -> if member is es then 1 else if member is os then -1 else 0)
          (take n (repeat1 n))

def ε' : Integer -> Integer -> Tensor Integer :=
  memoizedLambda n k ->
    let (es, os) := evenAndOddPermutations' n
     in generateTensor
          (\is ->
            match drop k is as list integer with
              | _ ++ $x :: _ ++ ?(< x) :: _ -> 0
              | _ -> if member is es then 1 else if member is os then -1 else 0)
          (take n (repeat1 n))
