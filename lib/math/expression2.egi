


--
-- Accessor
--
def fromMonomial (mexpr: MathExpr) : (MathExpr, MathExpr) :=
  match mexpr as mathExpr with
    | term $a $xs / term $b $ys ->
      (a / b, foldl (*') 1 (map (uncurry (^')) xs) / foldl (*') 1 (map (uncurry (^')) ys))

--
-- Map
--
def mapPolys (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | $p1 / $p2 -> fn p1 /' fn p2

def fromPoly (mexpr: MathExpr) : [MathExpr] :=
  match mexpr as mathExpr with
    | poly $ts1 / $q -> map (\t1 -> t1 /' q) ts1

def mapPoly (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | poly $ts1 / $q -> foldl (+') 0 (map (\t1 -> fn (t1 /' q)) ts1)

def mapTerms (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | poly $ts1 / poly $ts2 ->
      foldl (+') 0 (map fn ts1) /' foldl (+') 0 (map fn ts2)

def mapSymbols (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  mapTerms
    (\match as mathExpr with
      | term $a $xs ->
        a *' foldl
               (*')
               1
               (map
                  (\(x, n) -> match x as mathExpr with
                    | symbol _ _ -> fn x ^' n
                    | apply1 $g $a1 ->
                      let a1' := mapSymbols fn a1
                       in if a1 = a1'
                            then x ^' n
                            else fn `(g a1') ^' n
                    | apply2 $g $a1 $a2 ->
                      let a1' := mapSymbols fn a1
                          a2' := mapSymbols fn a2
                       in if a1 = a1' && a2 = a2'
                            then x ^' n
                            else fn `(g a1' a2') ^' n
                    | apply3 $g $a1 $a2 $a3 ->
                      let a1' := mapSymbols fn a1
                          a2' := mapSymbols fn a2
                          a3' := mapSymbols fn a3
                       in if a1 = a1' && a2 = a2' && a3 = a3'
                            then x ^' n
                            else fn `(g a1' a2' a3') ^' n
                    | apply4 $g $a1 $a2 $a3 $a4 ->
                      let a1' := mapSymbols fn a1
                          a2' := mapSymbols fn a2
                          a3' := mapSymbols fn a3
                          a4' := mapSymbols fn a4
                       in if a1 = a1' && a2 = a2' && a3 = a3' && a4 = a4'
                            then x ^' n
                            else fn `(g a1' a2' a3' a4') ^' n)
                  xs))
    mexpr

def scanAllTerms (mexpr: MathExpr) (f: MathExpr -> Bool) : Bool :=
  match mexpr as mathExpr with
    | poly $ts1 / poly $ts2 -> any f (ts1 ++ ts2)

def containSymbol (x: MathExpr) (mexpr: MathExpr) : Bool :=
  scanAllTerms mexpr
    (\match as termExpr with
      | term _ $xs ->
        any
          (\(y, _) -> match y as mathExpr with
            | #x -> True
            | apply1 _ $a1 -> containSymbol x a1
            | apply2 _ $a1 $a2 -> containSymbol x a1 || containSymbol x a2
            | apply3 _ $a1 $a2 $a3 -> containSymbol x a1 || containSymbol x a2 || containSymbol x a3
            | apply4 _ $a1 $a2 $a3 $a4 -> containSymbol x a1 || containSymbol x a2 || containSymbol x a3 || containSymbol x a4
            | _ -> False)
          xs)

def containFunction (f: MathExpr) (mexpr: MathExpr) : Bool :=
  scanAllTerms mexpr
    (\match as termExpr with
      | term _ $xs ->
        any
          (\(y, _) -> match y as mathExpr with
            | apply1 #f _ -> True
            | apply2 #f _ _ -> True
            | apply3 #f _ _ _ -> True
            | apply4 #f _ _ _ _ -> True
            | apply1 $g $a1 -> containFunction f a1
            | apply2 $g $a1 $a2 -> containFunction f a1 || containFunction f a2
            | apply3 $g $a1 $a2 $a3 -> containFunction f a1 || containFunction f a2 || containFunction f a3
            | apply4 $g $a1 $a2 $a3 $a4 -> containFunction f a1 || containFunction f a2 || containFunction f a3 || containFunction f a4
            | _ -> False)
          xs)

--
-- Substitute
--
def substitute (ls: [(MathExpr, MathExpr)]) (mexpr: MathExpr) : MathExpr :=
  match ls as list (symbolExpr, mathExpr) with
    | [] -> mathNormalize mexpr
    | ($x, $a) :: $rs -> substitute rs (substitute' x a mexpr)

def substitute' (x: MathExpr) (a: MathExpr) (mexpr: MathExpr) : MathExpr := 
  mapSymbols (rewriteSymbol x a) mexpr

def rewriteSymbol (x: MathExpr) (a: MathExpr) (sexpr: MathExpr) : MathExpr :=
  match sexpr as symbolExpr with
    | #x -> a
    | _ -> sexpr

def V.substitute (xs: Vector MathExpr) (ys: Vector MathExpr) (mexpr: MathExpr) : MathExpr :=
  substitute (zip (tensorToList xs) (tensorToList ys)) mexpr

def expandAll (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | ?isSymbol -> mexpr
    -- function application
    | apply1 $g $a1 -> `(g (expandAll a1))
    | apply2 $g $a1 $a2 -> `(g (expandAll a1) (expandAll a2))
    | apply3 $g $a1 $a2 $a3 -> `(g (expandAll a1) (expandAll a2) (expandAll a3))
    | apply4 $g $a1 $a2 $a3 $a4 -> `(g (expandAll a1) (expandAll a2) (expandAll a3) (expandAll a4))
    -- quote
    | quote $g -> g
    -- term (multiplication)
    | term $a $ps -> a * product (map (\(x, n) -> expandAll x ^ expandAll n) ps)
    -- polynomial
    | poly $ts -> sum (map expandAll ts)
    -- quotient
    | $p1 / $p2 -> expandAll p1 / expandAll p2

def expandAll' (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | ?isSymbol -> mexpr
    -- function application
    | apply1 $g $a1 -> `(g (expandAll' a1))
    | apply2 $g $a1 $a2 -> `(g (expandAll' a1) (expandAll' a2))
    | apply3 $g $a1 $a2 $a3 -> `(g (expandAll' a1) (expandAll' a2) (expandAll' a3))
    | apply4 $g $a1 $a2 $a3 $a4 -> `(g (expandAll' a1) (expandAll' a2) (expandAll' a3) (expandAll' a4))
    -- quote
    | quote $g -> g
    -- term (multiplication)
    | term $a $ps -> a *' product' (map (\(x, n) -> expandAll' x ^' expandAll' n) ps)
    -- polynomial
    | poly $ts -> sum' (map expandAll' ts)
    -- quotient
    | $p1 / $p2 -> expandAll' p1 / expandAll' p2

--
-- Coefficient
--
def coefficients (f: MathExpr) (x: MathExpr) : [MathExpr] :=
  let m := maximum
             (0 :: (matchAll f as mathExpr with
               | poly (term $a (#x ^ $k :: $ts) :: _) / _ -> k))
   in map (coefficient f x) (between 0 m)

def coefficient (f: MathExpr) (x: MathExpr) (m: Integer) : MathExpr :=
  if m = 0
    then sum
           (matchAll f as mathExpr with
             | poly (term $a (!(#x :: _) & $ts) :: _) / _ ->
               foldl (*') a (map (uncurry (^')) ts)) / denominator f
    else coefficient' f x m

def coefficient' (f: MathExpr) (x: MathExpr) (m: Integer) : MathExpr :=
  sum
    (matchAll f as mathExpr with
      | poly (term $a (#x ^ #m :: (!(#x :: _) & $ts)) :: _) / _ ->
        foldl (*') a (map (uncurry (^')) ts)) / denominator f

def coefficient2 (f: MathExpr) (x: MathExpr) (y: MathExpr) : MathExpr :=
  sum
    (matchAll f as mathExpr with
      | poly (term $a (#x :: #y :: $ts) :: _) / _ ->
        foldl (*') a (map (uncurry (^')) ts)) / denominator f

def L./ (xs: [MathExpr]) (ys: [MathExpr]) : ([MathExpr], [MathExpr]) :=
  if length xs < length ys
    then ([], xs)
    else match (ys, xs) as (list mathExpr, list mathExpr) with
      | ($y :: $yrs, $x :: $xrs) ->
        let (zs, rs) := L./
                          (map2
                             (-)
                             (take (length yrs) xrs)
                             (map (* (x / y)) yrs) ++ drop (length yrs) xrs)
                          ys
         in (x / y :: zs, rs)
