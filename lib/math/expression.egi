--
--
-- Mathematics Expressions
--
--

inductive pattern MathExpr :=
  | div MathExpr MathExpr
  | (/) MathExpr MathExpr
  | plus [MathExpr]
  | poly [MathExpr]
  | term Integer [(MathExpr, Integer)]
  | mult Integer MathExpr
  | (+) MathExpr MathExpr
  | (*) MathExpr MathExpr
  | (^) MathExpr Integer
  | symbol String [IndexExpr]
  | apply1 MathExpr MathExpr
  | apply2 MathExpr MathExpr MathExpr
  | apply3 MathExpr MathExpr MathExpr MathExpr
  | apply4 MathExpr MathExpr MathExpr MathExpr MathExpr
  | quote MathExpr
  | func MathExpr [MathExpr] [MathExpr]

inductive pattern IndexExpr :=
  | sub MathExpr
  | sup MathExpr
  | user MathExpr

def indexExpr : Matcher IndexExpr :=
  matcher
    | sub $ as (mathExpr) with
        | Sub $e -> [e]
        | _ -> []
    | sup $ as (mathExpr) with
        | Sup $e -> [e]
        | _ -> []
    | user $ as (mathExpr) with
        | User $e -> [e]
        | _ -> []
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def mathExpr : Matcher MathExpr :=
  matcher
    | div $ $ as (mathExpr, mathExpr) with
        | Div $p1 $p2 -> [(p1, p2)]
        | _ -> []
    | $ / $ as (mathExpr, mathExpr) with
        | Div $p1 $p2 -> [(p1, p2)]
        | _ -> []
    | poly $ as (multiset mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) -> [ts]
        | _ -> []
    | plus $ as (multiset mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) -> [ts]
        | _ -> []
    | $ + $ as (mathExpr, mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) ->
            matchAll ts as multiset something with
              | $t :: $tss -> (t, sum' tss)
        | _ -> []
    | term $ $ as (integer, assocMultiset mathExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, map (\(x, n) -> (x, n)) xs)]
        | _ -> []
    | mult $ $ as (integer, multExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, product' (map (\(x, n) -> x ^' n) xs))]
        | _ -> []
    | $ * $ as (integer, multExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, product' (map (\(x, n) -> x ^' n) xs))]
        | _ -> []
    | symbol $ $ as (eq, list indexExpr) with
        | Div (Plus [Term 1 [(Symbol $v $js, 1)]]) (Plus [Term 1 []]) ->
            [(v, js)]
        | _ -> []
    | apply1 $ $ as (mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply1 $v $a1, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1)]
        | _ -> []
    | apply2 $ $ $ as (mathExpr, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply2 $v $a1 $a2, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2)]
        | _ -> []
    | apply3 $ $ $ $ as (mathExpr, mathExpr, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply3 $v $a1 $a2 $a3, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2, a3)]
        | _ -> []
    | apply4 $ $ $ $ $ as (mathExpr, mathExpr, mathExpr, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply4 $v $a1 $a2 $a3 $a4, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2, a3, a4)]
        | _ -> []
    | quote $ as (mathExpr) with
        | Div (Plus [Term 1 [(Quote $mexpr, 1)]]) (Plus [Term 1 []]) ->
            [mexpr]
        | _ -> []
    | func $ $ $ as (mathExpr, list mathExpr, list mathExpr) with
        | Div
            (Plus [Term 1 [(Function $name $argnames $args, 1)]])
            (Plus [Term 1 []]) ->
            [(name, argnames, args)]
        | _ -> []
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def multExpr : Matcher MathExpr :=
  matcher
    | $ * $ as (mathExpr, multExpr) with
        | $tgt ->
            matchAll tgt as mathExpr with
              | term _ (($x, $n) :: $rs) -> (x ^' n, product' (map (\(x, n) -> x ^' n) rs))
    | $ ^ $ as (mathExpr, integer) with
        | $tgt ->
            match tgt as mathExpr with
              | term _ (($x, $n) :: []) -> [(x, n)]
              | _ -> []
    | $ * $ as (mathExpr, multExpr) with
        | $tgt ->
            matchAll tgt as mathExpr with
              | term _ (($x, $n) :: $rs) -> (x ^' n, product' (map (uncurry (^')) (map (\(x, n) -> (x, n)) rs)))
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def (+') : MathExpr -> MathExpr -> MathExpr := i.+
def (*') : MathExpr -> MathExpr -> MathExpr := i.*
def (^') : MathExpr -> Integer -> MathExpr := i.power
def sum' (xs: [MathExpr]) : MathExpr := foldl (+') 0 xs
def product' (xs: [MathExpr]) : MathExpr := foldl (*') 1 xs


def isSymbol (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | symbol _ _ -> True
    | _ -> False

