--
--
-- Mathematics Expressions
--
--

inductive pattern MathExpr :=
  | div MathExpr MathExpr
  | (/) MathExpr MathExpr
  | plus [MathExpr]
  | poly [MathExpr]
  | term Integer [(MathExpr, Integer)]
  | mult Integer MathExpr
  | (+) MathExpr MathExpr
  | (*) MathExpr MathExpr
  | (^) MathExpr Integer
  | symbol String [IndexExpr]
  | apply1 (MathExpr -> MathExpr) MathExpr
  | apply2 (MathExpr -> MathExpr -> MathExpr) MathExpr MathExpr
  | apply3 (MathExpr -> MathExpr -> MathExpr -> MathExpr) MathExpr MathExpr MathExpr
  | apply4 (MathExpr -> MathExpr -> MathExpr -> MathExpr -> MathExpr) MathExpr MathExpr MathExpr MathExpr
  | quote MathExpr
  | func MathExpr [MathExpr] [MathExpr]

inductive pattern IndexExpr :=
  | sub MathExpr
  | sup MathExpr
  | user MathExpr

def indexExpr : Matcher IndexExpr :=
  matcher
    | sub $ as (mathExpr) with
        | Sub $e -> [e]
        | _ -> []
    | sup $ as (mathExpr) with
        | Sup $e -> [e]
        | _ -> []
    | user $ as (mathExpr) with
        | User $e -> [e]
        | _ -> []
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def mathExpr : Matcher MathExpr :=
  matcher
    | div $ $ as (mathExpr, mathExpr) with
        | Div $p1 $p2 -> [(p1, p2)]
        | _ -> []
    | $ / $ as (mathExpr, mathExpr) with
        | Div $p1 $p2 -> [(p1, p2)]
        | _ -> []
    | poly $ as (multiset mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) -> [ts]
        | _ -> []
    | plus $ as (multiset mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) -> [ts]
        | _ -> []
    | $ + $ as (mathExpr, mathExpr) with
        | Div (Plus $ts) (Plus [Term 1 []]) ->
            matchAll ts as multiset something with
              | $t :: $tss -> (t, sum' tss)
        | _ -> []
    | term $ $ as (integer, assocMultiset mathExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, map (\(x, n) -> (x, n)) xs)]
        | _ -> []
    | mult $ $ as (integer, multExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, product' (map (\(x, n) -> x ^' n) xs))]
        | _ -> []
    | $ * $ as (integer, multExpr) with
        | Div (Plus [Term $n $xs]) (Plus [Term 1 []]) ->
            [(n, product' (map (\(x, n) -> x ^' n) xs))]
        | _ -> []
    | symbol $ $ as (something, list indexExpr) with
        | Div (Plus [Term 1 [(Symbol $v $js, 1)]]) (Plus [Term 1 []]) ->
            [(v, js)]
        | _ -> []
    | apply1 $ $ as (something, mathExpr) with
        | Div (Plus [Term 1 [(Apply1 $v $a1, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1)]
        | _ -> []
    | apply2 $ $ $ as (something, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply2 $v $a1 $a2, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2)]
        | _ -> []
    | apply3 $ $ $ $ as (something, mathExpr, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply3 $v $a1 $a2 $a3, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2, a3)]
        | _ -> []
    | apply4 $ $ $ $ $ as (something, mathExpr, mathExpr, mathExpr, mathExpr) with
        | Div (Plus [Term 1 [(Apply4 $v $a1 $a2 $a3 $a4, 1)]]) (Plus [Term 1 []]) ->
            [(v, a1, a2, a3, a4)]
        | _ -> []
    | quote $ as (mathExpr) with
        | Div (Plus [Term 1 [(Quote $mexpr, 1)]]) (Plus [Term 1 []]) ->
            [mexpr]
        | _ -> []
    | func $ $ $ as (mathExpr, list mathExpr, list mathExpr) with
        | Div
            (Plus [Term 1 [(Function $name $argnames $args, 1)]])
            (Plus [Term 1 []]) ->
            [(name, argnames, args)]
        | _ -> []
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def multExpr : Matcher MathExpr :=
  matcher
    | $ * $ as (mathExpr, multExpr) with
        | $tgt ->
            matchAll tgt as mathExpr with
              | term _ (($x, $n) :: $rs) -> (x ^' n, product' (map (\(x, n) -> x ^' n) rs))
    | $ ^ $ as (mathExpr, integer) with
        | $tgt ->
            match tgt as mathExpr with
              | term _ (($x, $n) :: []) -> [(x, n)]
              | _ -> []
    | $ * $ as (mathExpr, multExpr) with
        | $tgt ->
            matchAll tgt as mathExpr with
              | term _ (($x, $n) :: $rs) -> (x ^' n, product' (map (uncurry (^')) (map (\(x, n) -> (x, n)) rs)))
    | #$val as () with
        | $tgt -> if val = tgt then [()] else []
    | $ as something with
        | $tgt -> [tgt]

def (+') : MathExpr -> MathExpr -> MathExpr := i.+
def (*') : MathExpr -> MathExpr -> MathExpr := i.*
def (^') : MathExpr -> Integer -> MathExpr := i.power
def (/') : MathExpr -> MathExpr -> MathExpr := i./
def sum' (xs: [MathExpr]) : MathExpr := foldl (+') 0 xs
def product' (xs: [MathExpr]) : MathExpr := foldl (*') 1 xs


def isSymbol (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | symbol _ _ -> True
    | _ -> False

def isApply (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | apply1 _ _ -> True
    | apply2 _ _ _ -> True
    | apply3 _ _ _ _ -> True
    | apply4 _ _ _ _ _ -> True
    | _ -> False

def isSimpleTerm (mexpr: MathExpr) : Bool := isSymbol mexpr || isApply mexpr

def isTerm (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | term _ _ -> True
    | #0 -> True
    | _ -> False

def isPolynomial (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | poly _ -> True
    | #0 -> True
    | _ -> False

def isMonomial (mexpr: MathExpr) : Bool :=
  match mexpr as mathExpr with
    | poly [term _ _] / poly [term _ _] -> True
    | #0 -> True
    | _ -> False

--
-- Accessor
--
def fromMonomial (mexpr: MathExpr) : (MathExpr, MathExpr) :=
  match mexpr as mathExpr with
    | term $a $xs / term $b $ys ->
      (a / b, foldl (*') 1 (map (uncurry (^')) xs) / foldl (*') 1 (map (uncurry (^')) ys))

--
-- Map
--
def mapPolys (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | $p1 / $p2 -> fn p1 /' fn p2

def fromPoly (mexpr: MathExpr) : [MathExpr] :=
  match mexpr as mathExpr with
    | poly $ts1 / $q -> map (\t1 -> t1 /' q) ts1

def mapPoly (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | poly $ts1 / $q -> foldl (+') 0 (map (\t1 -> fn (t1 /' q)) ts1)

def mapTerms (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  match mexpr as mathExpr with
    | poly $ts1 / poly $ts2 ->
        foldl (+') 0 (map fn ts1) /' foldl (+') 0 (map fn ts2)

def mapSymbols (fn: MathExpr -> MathExpr) (mexpr: MathExpr) : MathExpr :=
  mapTerms
    (\match as mathExpr with
      | term $a $xs ->
          a *' foldl
                (*')
                1
                (map
                  (\(x, n) -> match x as mathExpr with
                      | symbol _ _ -> fn x ^' n
                      | apply1 $g $a1 ->
                          let a1' := mapSymbols fn a1
                          in if a1 = a1'
                              then x ^' n
                              else fn ('g a1') ^' n
                      | apply2 $g $a1 $a2 ->
                          let a1' := mapSymbols fn a1
                              a2' := mapSymbols fn a2
                          in if a1 = a1' && a2 = a2'
                              then x ^' n
                              else fn ('g a1' a2') ^' n
                      | apply3 $g $a1 $a2 $a3 ->
                          let a1' := mapSymbols fn a1
                              a2' := mapSymbols fn a2
                              a3' := mapSymbols fn a3
                          in if a1 = a1' && a2 = a2' && a3 = a3'
                              then x ^' n
                              else fn ('g a1' a2' a3') ^' n
                      | apply4 $g $a1 $a2 $a3 $a4 ->
                          let a1' := mapSymbols fn a1
                              a2' := mapSymbols fn a2
                              a3' := mapSymbols fn a3
                              a4' := mapSymbols fn a4
                          in if a1 = a1' && a2 = a2' && a3 = a3' && a4 = a4'
                              then x ^' n
                              else fn ('g a1' a2' a3' a4') ^' n)
                  xs))
    mexpr

def scanAllTerms (mexpr: MathExpr) (f: MathExpr -> Bool) : Bool :=
  match mexpr as mathExpr with
    | poly $ts1 / poly $ts2 -> any f (ts1 ++ ts2)

def containSymbol (x: MathExpr) (mexpr: MathExpr) : Bool :=
  scanAllTerms mexpr
    (\match as mathExpr with
      | term _ $xs ->
          any
            (\(y, _) -> match y as mathExpr with
              | #x -> True
              | apply1 _ $a1 -> containSymbol x a1
              | apply2 _ $a1 $a2 -> containSymbol x a1 || containSymbol x a2
              | apply3 _ $a1 $a2 $a3 -> containSymbol x a1 || containSymbol x a2 || containSymbol x a3
              | apply4 _ $a1 $a2 $a3 $a4 -> containSymbol x a1 || containSymbol x a2 || containSymbol x a3 || containSymbol x a4
              | _ -> False)
            xs)

def containFunction (f: MathExpr) (mexpr: MathExpr) : Bool :=
  scanAllTerms mexpr
    (\match as mathExpr with
      | term _ $xs ->
          any
            (\(y, _) -> match y as mathExpr with
              | apply1 #f _ -> True
              | apply2 #f _ _ -> True
              | apply3 #f _ _ _ -> True
              | apply4 #f _ _ _ _ -> True
              | apply1 $g $a1 -> containFunction f a1
              | apply2 $g $a1 $a2 -> containFunction f a1 || containFunction f a2
              | apply3 $g $a1 $a2 $a3 -> containFunction f a1 || containFunction f a2 || containFunction f a3
              | apply4 $g $a1 $a2 $a3 $a4 -> containFunction f a1 || containFunction f a2 || containFunction f a3 || containFunction f a4
              | _ -> False)
            xs)