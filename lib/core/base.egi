--
--
-- Base
--
--

-- | Type class for equality
class Eq a where
  (==) (x: a) (y: a) : Bool
  (/=) (x: a) (y: a) : Bool

-- | Eq instances for basic types
instance Eq Integer where
  (==) x y := x = y
  (/=) x y := not (x == y)

instance Eq Float where
  (==) x y := x = y
  (/=) x y := not (x == y)

instance Eq String where
  (==) x y := x = y
  (/=) x y := not (x == y)

instance Eq Bool where
  (==) x y := x = y
  (/=) x y := not (x == y)

instance Eq Char where
  (==) x y := x = y
  (/=) x y := not (x == y)

instance {Eq a} Eq (Tensor a) where
  (==) t1 t2 := t1 = t2
  (/=) t1 t2 := not (t1 == t2)

def eq {Eq a} : Matcher a :=
  matcher
    | #$val as () with
      | $tgt -> if val == tgt then [()] else []
    | $ as something with
      | $tgt -> [tgt]

def bool : Matcher Bool := eq
def char : Matcher Char := eq
def integer : Matcher Integer := eq
def float : Matcher Float := eq

-- Additive hierarchy
class AddSemigroup a where
  (+) (x: a) (y: a) : a

class AddMonoid a extends AddSemigroup a where
  zero : a

class AddGroup a extends AddMonoid a where
  neg (x: a) : a

-- Multiplicative hierarchy
class MulSemigroup a where
  (*) (x: a) (y: a) : a

class MulMonoid a extends MulSemigroup a where
  one : a

class MulGroup a extends MulMonoid a where
  inv (x: a) : a

-- Composite structures
class Ring a extends AddGroup a, MulMonoid a
class Field a extends Ring a, MulGroup a

-- Derived operators
def (-) {AddGroup a} (x: a) (y: a) : a := x + neg y
def (/) {Field a} (x: a) (y: a) : a := x * inv y

-- MathExpr instances
instance AddSemigroup MathExpr where
  (+) x y := plusForMathExpr x y

instance AddMonoid MathExpr where
  zero := 0

instance AddGroup MathExpr where
  neg x := minusForMathExpr 0 x

instance MulSemigroup MathExpr where
  (*) x y := multForMathExpr x y

instance MulMonoid MathExpr where
  one := 1

instance MulGroup MathExpr where
  inv x := divForMathExpr 1 x

instance Ring MathExpr
instance Field MathExpr

-- Float instances
instance AddSemigroup Float where
  (+) x y := f.+ x y

instance AddMonoid Float where
  zero := 0.0

instance AddGroup Float where
  neg x := f.- 0.0 x

instance MulSemigroup Float where
  (*) x y := f.* x y

instance MulMonoid Float where
  one := 1.0

instance MulGroup Float where
  inv x := f./ 1.0 x

instance Ring Float
instance Field Float

--
-- Utility
--

def id {a} (x: a) : a := x

def fst {a, b} (x: a, _: b) : a := x
def snd {a, b} (_: a, y: b) : b := y

def ($) {a, b} (f: a -> b) (x: a) : b := f x

def compose {a, b, c} (f: a -> b) (g: b -> c) : a -> c := \x -> g (f x)

def flip {a, b, c} (fn: a -> b -> c) : b -> a -> c := \x y -> fn y x

def eqAs {Eq a} (m: Matcher a) (x: a) (y: a) : Bool :=
  match x as m with
    | #y -> True
    | _ -> False

def curry {a, b, c} (f: (a, b) -> c) (x: a) (y: b) : c := f (x, y)
def uncurry {a, b, c} (f: a -> b -> c) (x: a, y: b) : c := f x y

--
-- Boolean
--

def (&&) (b1: Bool) (b2: Bool) : Bool := if b1 then b2 else False
def (||) (b1: Bool) (b2: Bool) : Bool := if b1 then True else b2

def not (b: Bool) : Bool := if b then False else True

--
-- Unordered Pair
--

def unorderedPair {a} (m: Matcher a) : Matcher (a, a) :=
  matcher
    | ($, $) as (m, m) with
      | ($x, $y) -> [(x, y), (y, x)]
    | $ as something with
      | $tgt -> [tgt]
