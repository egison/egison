--
--
-- Order
--
--

inductive Ordering := | Less | Equal | Greater

def ordering {a} : Matcher a :=
  algebraicDataMatcher
    | less
    | equal
    | greater

def min {Ord a} (x: a) (y: a) : a := if x < y then x else y
def max {Ord a} (x: a) (y: a) : a := if x > y then x else y

def minimum {Ord a} (xs: [a]) : a := foldl1 min xs
def maximum {Ord a} (xs: [a]) : a := foldl1 max xs

-- splitByOrdering uses $x pattern which doesn't support type annotations
def splitByOrdering {Ord a} (p: a) (xs: [a]) : ([a], [a], [a]) :=
  match xs as list something with
    | [] -> ([], [], [])
    | $x :: $rs ->
      let (ys1, ys2, ys3) := splitByOrdering p rs
       in match compare x p as ordering with
            | less -> (x :: ys1, ys2, ys3)
            | equal -> (ys1, x :: ys2, ys3)
            | greater -> (ys1, ys2, x :: ys3)

def sort {Ord a} (xs: [a]) : [a] :=
  match xs as list something with
    | [] -> []
    | $x :: [] -> [x]
    | _ ->
      let n := length xs
          p := nth (quotient n 2) xs
          (ys1, ys2, ys3) := splitByOrdering p xs
       in sort ys1 ++ ys2 ++ sort ys3

def merge {Ord a} (xs: [a]) (ys: [a]) : [a] :=
  match (xs, ys) as (list something, list something) with
    | ([], _) -> ys
    | (_, []) -> xs
    | ($x :: $txs, ?(>= x) :: _) -> x :: merge txs ys
    | (_, $y :: $tys) -> y :: merge xs tys

def minimize {a, Ord b} (f: a -> b) (xs: [a]) : a :=
  foldl1 (\x y -> if compare (f x) (f y) = Less then x else y) xs

def maximize {a, Ord b} (f: a -> b) (xs: [a]) : a :=
  foldl1 (\x y -> if compare (f x) (f y) = Greater then x else y) xs
