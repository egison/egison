--
-- Type Class Support Library
--


-- | Type class for comparison and ordering

-- | Type class for numeric types
class Num a where
  (+) (x: a) (y: a) : a
  (-) (x: a) (y: a) : a
  (*) (x: a) (y: a) : a
  negate (x: a) : a
  abs (x: a) : a
  fromInteger (n: Integer) : a

-- | Num instances for basic types
instance Num MathExpr where
  (+) x y        := plusForMathExpr x y
  (-) x y        := minusForMathExpr x y
  (*) x y        := multForMathExpr x y
  negate x       := neg x
  abs x          := abs x
  fromInteger n  := n

instance Num Float where
  (+) x y        := f.+ x y
  (-) x y        := f.- x y
  (*) x y        := f.* x y
  negate x       := f.neg x
  abs x          := f.abs x
  fromInteger n  := itof n

def repeatedSquaring {a} (fn: a -> a -> a) (x: a) (n: Integer) : a :=
  match n as integer with
    | #1      -> x
    | ?isEven ->
        let y := repeatedSquaring fn x (quotient n 2)
         in fn y y
    | ?isOdd  ->
        let y := repeatedSquaring fn x (quotient n 2)
         in fn (fn y y) x

inductive pattern Integer :=
  | o
  | s Integer

def nat : Matcher Integer :=
  matcher
    | o as () with
      | 0   -> [()]
      | _   -> []
    | s $ as nat with
      | $tgt ->
          match compare tgt 0 as ordering with
            | greater -> [tgt - 1]
            | _       -> []
    | #$n as () with
      | $tgt -> if tgt = n then [()] else []
    | $ as (something) with
      | $tgt -> [tgt]

def showDecimal (c: Integer) (x: Integer) : String :=
  match (2)#($1, take c $2) (rtod x) as (integer, list integer) with
    | ($q, $sc) -> foldl S.append (S.append (show q) ".") (map show sc)

def showDecimal' (x: Integer) : String :=
  match rtod' x as (integer, list integer, list integer) with
    | ($q, $s, $c) ->
        foldl
          S.append
          ""
          (S.append (show q) "." :: map show s ++ " " :: map show c ++ [" ..."])

--
-- Sort
--

-- input:  collection of collection of integers
-- output: a tuple of type (int, collection of integers)
--   where the first element is 1 if the number of swap needed to sort the input
--   is even, and -1 otherwise
--   and the second element is the sorted collection represented as a 1-d tensor
--   (vector)
def sortWithSign {Ord a} (xs: [[a]]) : (Integer, [a]) :=
  match xs as list something with
  -- Optimization for the case where the length is less than 3
  | [] -> (1, xs)
  | [$x] -> (1, x)
  | [$x, $y] ->
    if compare x y = Greater then (-1, y ++ x) else (1, x ++ y)
  | _ ->
    io (do let t := return (colToTensor xs)
           let n := return (length xs)
           let sgn := sort' 1 2 n t 1
           let xs' := return (map (\i -> io $ readIORef t_i) [1..n])
           return (sgn, concat xs'))
 where
  colToTensor {a} (xs: [[a]]) : Tensor (IORef [a]) :=
    generateTensor (\[n] -> io $
      do let t := newIORef ()
         writeIORef t (nth n xs)
         return t) [length xs]

  sort' {Ord a} (i: Integer) (j: Integer) (n: Integer) (ts: Tensor (IORef [a])) (sgn: Integer) 
    : IO Integer :=
    if i = n
       then return sgn
       else do let x := readIORef ts_i
               let y := readIORef ts_j
               if compare x y = Greater then swap ts i j else return ()
               let swapped := return (if compare x y = Greater then -1 else 1)
               if j = n then sort' (i + 1) (i + 2) n ts (sgn * swapped)
                        else sort' i (j + 1) n ts (sgn * swapped)

  swap {a} (ts: Tensor (IORef [a])) (i: Integer) (j: Integer) : IO () := do
    let tmpi := readIORef ts_i
    let tmpj := readIORef ts_j
    writeIORef ts_i tmpj
    writeIORef ts_j tmpi


def M.inverse {Num a} (m: Matrix a) : Matrix a :=
  let d := M.det m
   in generateTensor
        (\[i, j] ->
          match m as matrix with
          | cons #j #i _ $A $B $C $D ->
            if isEven (i + j)
              then M.det (M.join A B C D) / d
              else - (M.det (M.join A B C D) / d))
        (tensorShape m)

def matrix {} : Matcher Integer :=
  matcher
    | quadCons $ $ $ $ as (mathExpr, matrix, matrix, matrix) with
      | $tgt ->
        match tensorShape tgt as list integer with
          | $m :: $n :: _ ->
            [(tgt_1_1, tgt_1_(2, n), tgt_(2, m)_1, tgt_(2, m)_(2, n))]
          | _ -> []
    | cons #$i #$j $ $ $ $ $ as (mathExpr, matrix, matrix, matrix, matrix) with
      | $tgt ->
        let ns := tensorShape tgt
            m := nth 1 ns
            n := nth 2 ns
         in [ ( tgt_i_j
            , tgt_(1, i - 1)_(1, j - 1)
            , tgt_(1, i - 1)_(j + 1, n)
            , tgt_(i + 1, m)_(1, j - 1)
            , tgt_(i + 1, m)_(j + 1, n) ) ]
    | #$val as () with
      | $tgt -> if val = tgt then [()] else []
    | $ as (something) with
      | $tgt -> [tgt]
