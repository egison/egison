--
-- Type Class Support Library
--


-- | Type class for comparison and ordering

-- | Type class for numeric types
class Num a where
  (+) (x: a) (y: a) : a
  (-) (x: a) (y: a) : a
  (*) (x: a) (y: a) : a
  negate (x: a) : a
  abs (x: a) : a
  fromInteger (n: Integer) : a

-- | Num instances for basic types
instance Num MathExpr where
  (+) x y        := plusForMathExpr x y
  (-) x y        := minusForMathExpr x y
  (*) x y        := multForMathExpr x y
  negate x       := neg x
  abs x          := abs x
  fromInteger n  := n

instance Num Float where
  (+) x y        := f.+ x y
  (-) x y        := f.- x y
  (*) x y        := f.* x y
  negate x       := f.neg x
  abs x          := f.abs x
  fromInteger n  := itof n

def repeatedSquaring {a} (fn: a -> a -> a) (x: a) (n: Integer) : a :=
  match n as integer with
    | #1      -> x
    | ?isEven ->
        let y := repeatedSquaring fn x (quotient n 2)
         in fn y y
    | ?isOdd  ->
        let y := repeatedSquaring fn x (quotient n 2)
         in fn (fn y y) x

inductive pattern Integer :=
  | o
  | s Integer

def nat : Matcher Integer :=
  matcher
    | o as () with
      | 0   -> [()]
      | _   -> []
    | s $ as nat with
      | $tgt ->
          match compare tgt 0 as ordering with
            | greater -> [tgt - 1]
            | _       -> []
    | #$n as () with
      | $tgt -> if tgt = n then [()] else []
    | $ as (something) with
      | $tgt -> [tgt]

def showDecimal (c: Integer) (x: Integer) : String :=
  match (2)#($1, take c $2) (rtod x) as (integer, list integer) with
    | ($q, $sc) -> foldl S.append (S.append (show q) ".") (map show sc)

def showDecimal' (x: Integer) : String :=
  match rtod' x as (integer, list integer, list integer) with
    | ($q, $s, $c) ->
        foldl
          S.append
          ""
          (S.append (show q) "." :: map show s ++ " " :: map show c ++ [" ..."])

--
-- Sort
--

-- input:  collection of collection of integers
-- output: a tuple of type (int, collection of integers)
--   where the first element is 1 if the number of swap needed to sort the input
--   is even, and -1 otherwise
--   and the second element is the sorted collection represented as a 1-d tensor
--   (vector)
def sortWithSign {Ord a} (xs: [[a]]) : (Integer, [a]) :=
  match xs as list something with
  -- Optimization for the case where the length is less than 3
  | [] -> (1, xs)
  | [$x] -> (1, x)
  | [$x, $y] ->
    if compare x y = Greater then (-1, y ++ x) else (1, x ++ y)
  | _ ->
    io (do let t := return (colToTensor xs)
           let n := return (length xs)
           let sgn := sort' 1 2 n t 1
           let xs' := return (map (\i -> io $ readIORef t_i) [1..n])
           return (sgn, concat xs'))
 where
  colToTensor {a} (xs: [[a]]) : Tensor (IORef [a]) :=
    generateTensor (\[n] -> io $
      do let t := newIORef ()
         writeIORef t (nth n xs)
         return t) [length xs]

  sort' {Ord a} (i: Integer) (j: Integer) (n: Integer) (ts: Tensor (IORef [a])) (sgn: Integer) 
    : IO Integer :=
    if i = n
       then return sgn
       else do let x := readIORef ts_i
               let y := readIORef ts_j
               if compare x y = Greater then swap ts i j else return ()
               let swapped := return (if compare x y = Greater then -1 else 1)
               if j = n then sort' (i + 1) (i + 2) n ts (sgn * swapped)
                        else sort' i (j + 1) n ts (sgn * swapped)

  swap {a} (ts: Tensor (IORef [a])) (i: Integer) (j: Integer) : IO () := do
    let tmpi := readIORef ts_i
    let tmpj := readIORef ts_j
    writeIORef ts_i tmpj
    writeIORef ts_j tmpi


--
-- Eigenvalues and eigenvectors
--
def M.eigenvalues {Num a} (m: Matrix a) : [a] :=
  let (e1, e2) := qF (M.det (T.- m (scalarToTensor x [2, 2]))) x
   in [e1, e2]

def M.eigenvectors {Num a} (m: Matrix a) : [(a, Vector a)] :=
  let (e1, e2) := qF (M.det (T.- m (scalarToTensor x [2, 2]))) x
   in [ (e1, clearIndex (T.- m (scalarToTensor e1 [2, 2]))_i_1)
      , (e2, clearIndex (T.- m (scalarToTensor e2 [2, 2]))_i_1) ]

--
-- LU decomposition
--
def M.LU {Num a} (x: Matrix a) : (Matrix a, Matrix a) :=
  match tensorShape x as list integer with
    | [#2, #2] ->
      let L := generateTensor
                 (\[i, j] -> match compare i j as ordering with
                   | less -> 0
                   | equal -> 1
                   | greater -> b_i_j)
                 [2, 2]
          U := generateTensor
                 (\[i, j] -> match compare i j as ordering with
                   | greater -> 0
                   | _ -> c_i_j)
                 [2, 2]
          m := M.* L U
          ret := solve
                   [ (m_1_1, x_1_1, c_1_1)
                   , (m_1_2, x_1_2, c_1_2)
                   , (m_2_1, x_2_1, b_2_1)
                   , (m_2_2, x_2_2, c_2_2) ]
       in (substitute ret L, substitute ret U)
    | [#3, #3] ->
      let L := generateTensor
                 (\[i, j] -> match compare i j as ordering with
                   | less -> 0
                   | equal -> 1
                   | greater -> b_i_j)
                 [3, 3]
          U := generateTensor
                 (\[i, j] -> match compare i j as ordering with
                   | greater -> 0
                   | _ -> c_i_j)
                 [3, 3]
          m := M.* L U
          ret := solve
                   [ (m_1_1, x_1_1, c_1_1)
                   , (m_1_2, x_1_2, c_1_2)
                   , (m_1_3, x_1_3, c_1_3)
                   , (m_2_1, x_2_1, b_2_1)
                   , (m_2_2, x_2_2, c_2_2)
                   , (m_2_3, x_2_3, c_2_3)
                   , (m_3_1, x_3_1, b_3_1)
                   , (m_3_2, x_3_2, b_3_2)
                   , (m_3_3, x_3_3, c_3_3) ]
       in (substitute ret L, substitute ret U)
    | _ -> undefined

--
-- Utility
--
def generateMatrixFromQuadraticExpr {a} (f: a) (xs: [a]) : Matrix a :=
  generateTensor
    (\[i, j] -> coefficient2 f (nth i xs) (nth j xs))
    [length xs, length xs]
