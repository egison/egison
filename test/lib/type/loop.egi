-- Loop pattern type inference tests

-- Test 1: Basic loop pattern with indexed pattern variable
-- The indexed pattern variable $h_i has type: Hash Integer Integer
-- because it accumulates values indexed by the loop variable i
def collectFirst2 :=
  matchAll [1, 2, 3, 4] as list integer with
  | loop $i (1, 2)
      ($h_i :: ...)
      _
  -> h

-- h : Hash Integer Integer
-- Result: one hash where h_1=1, h_2=2
assertEqual "loop pattern basic" (length collectFirst2) 1
assertEqual "loop pattern hash" (head collectFirst2) {|(1, 1), (2, 2)|}

-- Test 2: Access hash elements using map
def accessHash :=
  matchAll [10, 20, 30, 40] as list integer with
  | loop $i (1, 3)
      ($h_i :: ...)
      _
  -> map (\j -> h_j) [1, 2, 3]

assertEqual "loop pattern hash access" (head accessHash) [10, 20, 30]

-- Test 3: Loop pattern with continuation
-- $rest captures the remaining elements after the loop
def withContinuation :=
  matchAll [1, 2, 3, 4, 5] as list integer with
  | loop $i (1, 2)
      ($h_i :: ...)
      $rest
  -> (map (\j -> h_j) [1, 2], rest)

-- rest : [Integer] - the remaining list after extracting 2 elements
assertEqual "loop with continuation" (head withContinuation) ([1, 2], [3, 4, 5])

-- Test 4: n-queens example (from sample/n-queens.egi)
-- This demonstrates:
-- - Nested loop patterns
-- - Loop index variable i, j : Integer
-- - Indexed pattern variable a_i, a_j : Hash Integer Integer
def nQueens n := matchAll [1..n] as multiset integer with
  | $a_1 ::
      (loop $i (2, n)
         ((loop $j (1, i - 1)
             (!#(a_j - (i - j)) & !#(a_j + (i - j)) & ...)
             $a_i) :: ...)
         [])
  -> map (\k -> a_k) [1..n]

assertEqual "nQueens 4" (nQueens 4) [[2, 4, 1, 3], [3, 1, 4, 2]]

-- Test 5: Loop variable used in body expression
def loopWithIndex :=
  matchAll [1, 2, 3] as list integer with
  | loop $i (1, 2)
      ($h_i :: ...)
      _
  -> map (\idx -> h_idx * idx) [1, 2]

-- h_1 = 1, h_2 = 2
-- Result: [1*1, 2*2] = [1, 4]
assertEqual "loop index access" (head loopWithIndex) [1, 4]

-- Test 6: Loop with predicate pattern
def loopWithPredicate :=
  matchAll [1, 2, 3, 4, 5] as list integer with
  | loop $i (1, 2)
      ((?(\x -> x > 0) & $h_i) :: ...)
      _
  -> (h_1, h_2)

assertEqual "loop with predicate" (head loopWithPredicate) (1, 2)

-- ===========================================
-- LetPat tests
-- ===========================================

-- Test 7: Basic LetPat - let binding in pattern
-- let x := 10 in pattern binds x to 10
def letPatBasic :=
  matchAll [1, 2, 3] as list integer with
  | let x := 10 in $y :: _ -> x + y

-- x : Integer (from let binding), y : Integer (from pattern)
assertEqual "LetPat basic" (head letPatBasic) 11

-- Test 8: LetPat with tuple binding
def letPatTuple :=
  matchAll [1, 2, 3] as list integer with
  | let (a, b) := (100, 200) in $y :: _ -> a + b + y

assertEqual "LetPat tuple" (head letPatTuple) 301

-- Test 9: LetPat with multiple bindings
def letPatMultiple :=
  matchAll [1, 2, 3] as list integer with
  | let x := 10
        y := 20
    in $z :: _ -> x + y + z

assertEqual "LetPat multiple" (head letPatMultiple) 31

-- Test 10: LetPat with expression using outer variables
def letPatWithExpr :=
  matchAll [(1, 2), (3, 4)] as list (integer, integer) with
  | ($a, $b) :: _ ->
      let sum := a + b in
      matchAll [1, 2, 3] as list integer with
      | $x :: _ -> sum + x

-- sum = 1 + 2 = 3, x = 1, result = 3 + 1 = 4
assertEqual "LetPat with expr" (head (head letPatWithExpr)) 4

"Loop and LetPat type tests completed"
