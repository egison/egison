# 代数拡大体における式の簡約

## 課題

現在のEgisonの数式処理システムでは、項ごとの書き換え規則（rewrite rules）で式の簡約を行っている。しかし、**代数拡大体上の多項式レベルの零判定（zero testing）**ができないため、一部の式が簡約できない。

### 具体例：1の5乗根

`sample/math/number/5th-root-of-unity.egi` で `z1'^5 = 1` の検証が失敗する。

```
s = √5,  u = √(-5 - 2√5),  v = √(-5 + 2√5)
```

とおくと、`z1'^5` の計算過程で以下の式が現れる：

```
u · (-125 + 55s) + v · (-25 + 15s) = 0
```

この恒等式が成り立つのは `v = u · (s - 2)` という代数的関係があるためである：

```
v² = -5 + 2√5
u² · (s-2)² = (-5-2√5)(5 - 4√5 + 4) = (-5-2√5)(9-4√5)
            = -45 + 20√5 - 18√5 + 8·5 = -45 + 2√5 + 40 = -5 + 2√5
```

よって `v² = u²(s-2)²` であり、適切な符号選択で `v = u(s-2)` が成立する。

これを代入すると：

```
u(-125 + 55s) + u(s-2)(-25 + 15s) = u(-125 + 55s - 25s + 15s² + 50 - 30s)
                                    = u(-75 + 0·s + 15·5)
                                    = u · 0 = 0
```

現在のterm-by-termの書き換えでは、異なる項に属する `u` と `v` の間の代数的関係を利用できないため、この消去ができない。

## 現在の簡約アーキテクチャの限界

`hs-src/Language/Egison/Math/Rewrite.hs` の `rewriteSqrt` は、単一の項（`TermExpr`）内のモノミアルに含まれるsqrtペアを処理する。

- Rule 1: `sqrt(x)^k` → `x^(k/2) * sqrt(x)^(k mod 2)`
- Rule 2: `sqrt(singleTerm n x) * sqrt(singleTerm m y)` → GCDを使って簡約
- Rule 3: `findSqrtPairToMerge` → 積が単一項に簡約されるsqrtペアをマージ

これらはすべて**単一の項のモノミアル内**で完結しており、**多項式全体**（`PolyExpr`）にまたがる代数的関係は扱えない。

## 解決のアイデア

### アプローチ1: 代数拡大体の最小多項式による正規化

他の数式処理システム（Mathematica、Mapleなど）が採用している手法。

**概要**: 各√記号を代数的数として扱い、その最小多項式を用いて正規化する。

**手順**:
1. 式に含まれるすべての√記号を収集し、基底を構成する
   - 例: `s = √5`, `u = √(-5-2√5)`, `v = √(-5+2√5)`
2. 各記号の最小多項式を求める
   - `s² - 5 = 0`
   - `u² - (-5-2s) = 0` → `u² + 5 + 2s = 0`
   - `v² - (-5+2s) = 0` → `v² + 5 - 2s = 0`
3. 記号間の代数的関係を発見する
   - `u·v` の最小多項式: `(uv)² = (-5-2s)(-5+2s) = 25-4·5 = 5` → `uv = ±√5 = ±s`
   - 符号決定により `uv = -s`
4. これらの関係を使って、商環 `Q(s)[u,v] / (s²-5, u²+5+2s, v²+5-2s, uv+s)` で正規化
5. 正規化された式が0かどうかを判定

**利点**: 一般的で強力。多くの代数的恒等式を自動的に検出・利用できる。

**課題**: 
- 最小多項式の計算（特にネストした√の場合）
- グレブナー基底の計算が必要になる可能性
- 実装の複雑さ

### アプローチ2: √記号間の関係の自動検出と代入

アプローチ1の簡略版。

**概要**: √記号のペアの積が既知の√で表現できる場合、代入によって記号の数を減らす。

**手順**:
1. 式中のすべての√記号のペアについて積を計算
2. 積が既存の√記号や定数で表現できる場合、関係式を記録
   - 例: `u·v = -s` が判明
3. 最も少ない記号で式を表現できるよう、代入を行う
   - `v = -s/u` を代入して `v` を除去
4. 残った式を既存のルールで簡約

**利点**: グレブナー基底の計算が不要。既存の `findSqrtPairToMerge` の延長で実装可能。

**課題**: 
- どの記号をどの記号で置き換えるかの選択（ヒューリスティック）
- `v = -s/u` のような分数式の扱い
- 一般性に欠ける（すべてのケースを網羅しない）

### アプローチ3: 商環でのリダクション（推奨）

アプローチ1と2の中間的な手法。

**概要**: √記号に対応する代数的関係（`s²=5`, `u²=-5-2s`, `uv=-s` など）を集め、多項式リダクションにより正規形を求める。

**手順**:
1. √記号 `x` に対して `x² = (引数)` という関係式を自動生成
2. ペアの積から追加の関係式を発見（`findSqrtPairToMerge` の拡張）
3. 関係式を用いた多項式リダクション:
   - 式を `s, u, v` の多変数多項式として扱う
   - 各変数の次数を関係式で下げる（例: `s²` → `5`, `u²` → `-5-2s`）
   - これを固定点に達するまで繰り返す
4. リダクション結果が0なら元の式は0

**具体的な実装イメージ**:

```haskell
-- 代数的関係のデータ型
data AlgRelation = AlgRelation
  { relLhs :: SymbolExpr          -- 左辺（e.g., v）
  , relRhs :: ScalarData           -- 右辺（e.g., u*(s-2)）
  }

-- 多項式中のすべての√記号を収集
collectSqrtSymbols :: ScalarData -> [SymbolExpr]

-- √記号間の代数的関係を発見
discoverRelations :: [SymbolExpr] -> [AlgRelation]

-- 関係式を用いて多項式をリダクション
reduceByRelations :: [AlgRelation] -> ScalarData -> ScalarData
```

**利点**: 
- 実装の複雑さが中程度
- 既存のアーキテクチャ（`rewriteSymbol`のパイプライン）に自然に組み込める
- 1の5乗根のようなケースを確実に処理できる

**課題**: 
- リダクション順序の選択（合流性の保証）
- 関係式の発見の網羅性

## 実装の優先順位

1. **まず**: アプローチ3の基本形を `rewriteSymbol` のパイプラインに新しいパスとして追加
   - `s² → 5`, `u² → -5-2s`, `v² → -5+2s` の自動生成
   - `uv → -s` の発見（既存の `findSqrtPairToMerge` を拡張）
   - 多項式リダクションの実装
2. **次に**: 符号決定の改善（`isNegativeScalar` の拡張）
3. **将来**: 必要に応じてグレブナー基底の計算を導入

## 関連ファイル

- `hs-src/Language/Egison/Math/Rewrite.hs` - 書き換え規則の実装
- `hs-src/Language/Egison/Math/Expr.hs` - 数式のデータ型定義
- `hs-src/Language/Egison/Math/Normalize.hs` - 正規化処理
- `hs-src/Language/Egison/Math/Arith.hs` - 算術演算
- `sample/math/number/5th-root-of-unity.egi` - テストケース
