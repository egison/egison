型クラス展開とTensorMap挿入のコードを整理したい。

~~現在、型クラス展開の後にTensorMapを挿入しているが、逆にしたい。~~
**✅ 実装完了**: TensorMapの挿入後に型クラス展開する順序に変更しました。
そのメリット:
型クラス展開時には、引数がスカラー型かテンソル型か確定しているため、型クラス展開時にunifyStrictを使えるようになる。

TensorMap挿入については、design/tensor-map-insertion-simple.mdに詳しく書いてある。
現在のTensorMap挿入は型クラス展開後に行われるため、クラス制約などを検査する処理が抜けていて問題を起こす可能性があるので調べる必要がある。

TensorMap挿入にはeta展開を事前にすることが必要か？
高階関数として、関数の引数に渡された関数についてはeta展開した方が良いかもしれない。

リファクタリング後も
cabal run egison -- -t sample/math/geometry/riemann-curvature-tensor-of-S2.egi
が問題なくTrueという文字列のみが出力されるようにしてほしい。

# デバッグの方法

まずは単純な関数についてtensorMapが挿入されているか確認する。
--dump-tiオプションの出力結果を見れば確認できる。

```
def t1 := [| 1, 2, 3 |]
def t2 := [| 10, 20, 30 |]

i.+ 1 10 -- 挿入されない

i.+ t1 t2 -- 挿入される
```

とりあえず、まずはここまでの動作確認をしてほしい。
--no-preludeオプションを使って、ライブラリをロードしない必要もありそう。

その後、クラスメソッドについてもtensorMapが挿入されるか確認する。
--dump-tiオプションの出力結果を見れば確認できる。

```
def t1 := [| 1, 2, 3 |]
def t2 := [| 10, 20, 30 |]

1 + 10 -- 挿入されない

t1 + t2 -- 挿入される
```

仮引数の型が{Num a} aのようにテンソル型がunifyStrictでunifyできない型である場合は、tensorMapを挿入する。
仮引数の型がTensor aやaのようにテンソルとunifyできる型である場合は、tensorMapを挿入しない。
上記のコードを実行できない場合、現在のtensorMapInsertion.hsの実装は上記のクラス制約を正しく処理できていない可能性がある。

その後、高階関数についてもtensorMapが挿入されるか確認する。
--dump-tiオプションの出力結果から"def sum"を検索すれば確認できる。
